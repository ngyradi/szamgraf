<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "./js-r178/build/three.module.js",
          "TrackballControls": "./js-r178/examples/jsm/controls/TrackballControls.js",
          "OBJLoader": "./js-r178/examples/jsm/loaders/OBJLoader.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { TrackballControls } from "TrackballControls";
      import { OBJLoader } from "OBJLoader";

      let WIDTH, HEIGHT, aspectRatio;
      let renderer;
      let scene, camera;
      let geometry, material, mesh;
      let controls;
      let ambientLight, pointLight, directionalLight;

      async function loadTree() {
        const loader = new OBJLoader();
        const object = await loader.loadAsync("fa.obj");

        object.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            child.material = new THREE.MeshLambertMaterial({
              color: 0x6b1717,
              side: THREE.DoubleSide,
            });
          }
        });

        return object;
      }

      init();
      animate();

      async function init() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0x000000);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.z = 100;
        camera.position.y = 40;
        camera.lookAt(scene.position);

        createTerrain();
        createTrees();

        ambientLight = new THREE.AmbientLight(0xf0f0f0, 1);
        // ambientLight = new THREE.AmbientLight(0xecf300, 5);

        scene.add(ambientLight);
        // spotLight = new THREE.SpotLight(0xffffff, 50000);
        // spotLight.position.set(-40, 50, 20);
        // spotLight.angle = Math.PI / 8;
        // spotLight.target = treeTrunkMesh;
        // spotLight.penumbra = 0.8;
        // spotLight.distance = 5000;
        // spotLight.castShadow = true;

        // const arrowHelper = new THREE.ArrowHelper(
        //   spotLight.position.clone().normalize(),
        //   new THREE.Vector3(0, 0, 0),
        //   25,
        //   0x00ff00
        // );
        // scene.add(spotLight);
        // scene.add(arrowHelper);

        // pointLight = new THREE.PointLight(0xff0000, 2000, 100);
        // pointLight.position.set(15, 10, -10);

        // pointLight.castShadow = true;
        // scene.add(pointLight);

        // const pointHelper = new THREE.Mesh(
        //   new THREE.SphereGeometry(1),
        //   new THREE.MeshBasicMaterial({ color: 0xff0000 })
        // );
        // pointHelper.position.copy(pointLight.position);
        // scene.add(pointHelper);

        // const directionalLight = new THREE.DirectionalLight(0x0000ff, 10);
        // directionalLight.position.set(-50, 10, 5);
        // directionalLight.castShadow = true;
        // scene.add(directionalLight);

        // const dirHelper = new THREE.ArrowHelper(
        //   directionalLight.position.clone().normalize(),
        //   new THREE.Vector3(0, 0, 0),
        //   50,
        //   0x00ff00
        // );
        // scene.add(dirHelper);

        controls = new TrackballControls(camera, renderer.domElement);

        window.addEventListener("resize", handleWindowResize, false);
      }

      function createTerrain() {
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x38a800,
          displacementMap: new THREE.TextureLoader().load(
            "river_displacement.png"
          ),
          displacementScale: 0.5,
        });

        const waterMaterial = new THREE.MeshPhongMaterial({
          color: 0x0000cc,
          specular: 0xffffff,
          shininess: 10,
        });

        const planeGeometry = new THREE.PlaneGeometry(10, 10, 256, 256);
        const planeMesh = new THREE.Mesh(planeGeometry, groundMaterial);

        planeMesh.receiveShadow = true;

        planeMesh.position.set(0, -5, 0);
        planeMesh.scale.set(50, 50, 50);
        planeMesh.rotation.x = -Math.PI / 2;

        scene.add(planeMesh);

        const waterGeometry = new THREE.PlaneGeometry(10, 10, 4, 4);
        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);

        waterMesh.position.set(0, 16, 0);
        waterMesh.scale.set(50, 50, 50);
        waterMesh.rotation.x = -Math.PI / 2;

        scene.add(waterMesh);
      }

      async function createTrees() {
        const treePositions = [
          { x: -243, z: -243, rotation: 9 },
          { x: 120, z: -87, rotation: 3 },
          { x: -45, z: 200, rotation: 15 },
          { x: 250, z: -12, rotation: 0 },
          { x: -210, z: 134, rotation: 14 },
          { x: 56, z: 220, rotation: 5 },
          { x: 33, z: 188, rotation: 6 },
          { x: -67, z: -199, rotation: 12 },
          { x: 201, z: 77, rotation: 4 },
          { x: 75, z: -220, rotation: 10 },
          { x: -188, z: 99, rotation: 13 },
          { x: 222, z: -56, rotation: 9 },
          { x: -44, z: 144, rotation: 15 },
          { x: 98, z: -88, rotation: 0 },
          { x: -156, z: 233, rotation: 7 },
          { x: 187, z: -177, rotation: 2 },
          { x: -250, z: -111, rotation: 5 },
          { x: -77, z: 66, rotation: 3 },
          { x: 210, z: -34, rotation: 12 },
          { x: -199, z: 188, rotation: 6 },
          { x: 45, z: -145, rotation: 8 },
          { x: -88, z: 222, rotation: 11 },
          { x: -33, z: 99, rotation: 4 },
          { x: 144, z: -67, rotation: 13 },
          { x: 188, z: -201, rotation: 10 },
          { x: -56, z: 132, rotation: 9 },
          { x: 99, z: -75, rotation: 15 },
          { x: -220, z: 187, rotation: 2 },
          { x: -111, z: 134, rotation: 5 },
          { x: -34, z: 210, rotation: 3 },
          { x: 222, z: -88, rotation: 8 },
          { x: 99, z: -33, rotation: 16 },
          { x: -67, z: 144, rotation: 4 },
          { x: -201, z: 75, rotation: 1 },
        ];

        const treeModel = await loadTree();

        for (const position of treePositions) {
          const clone = treeModel.clone(true);

          clone.scale.set(5, 5, 5);
          clone.position.set(position.x, 24, position.z);

          clone.rotation.y = (Math.PI / 16) * position.rotation;

          scene.add(clone);
        }
      }

      function handleWindowResize() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize(WIDTH, HEIGHT);
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();

        controls.handleResize();

        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
