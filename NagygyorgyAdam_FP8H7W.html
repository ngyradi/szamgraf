<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "./js-r178/build/three.module.js",
          "TrackballControls": "./js-r178/examples/jsm/controls/TrackballControls.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { TrackballControls } from "TrackballControls";

      let WIDTH, HEIGHT, aspectRatio;
      let renderer;
      let scene, camera;
      let geometry, material, mesh;
      let controls;
      let ambientLight, spotLight, pointLight, directionalLight;
      let treeTrunkMesh;

      init();
      animate();

      function init() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0x000000);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.z = 100;
        camera.position.y = 40;
        camera.lookAt(scene.position);

          createModel();

          ambientLight = new THREE.AmbientLight( 0xf0f0f0, 0.15 );

          scene.add( ambientLight );
          spotLight = new THREE.SpotLight( 0xffffff, 50000 );
          spotLight.position.set( -40, 50, 20 );
          spotLight.angle = Math.PI / 8;
          spotLight.target = treeTrunkMesh;
          spotLight.penumbra = 0.8;
          spotLight.distance = 5000;
          spotLight.castShadow = true;

          const arrowHelper = new THREE.ArrowHelper(
              spotLight.position.clone().normalize(),
              new THREE.Vector3(0, 0, 0),
              25,
              0x00ff00
          );
          scene.add(spotLight);
          scene.add(arrowHelper);

          pointLight = new THREE.PointLight(0xff0000, 2000, 100);
          pointLight.position.set(15, 10, -10);

          pointLight.castShadow = true;
          scene.add(pointLight);

          const pointHelper = new THREE.Mesh(
              new THREE.SphereGeometry(1),
              new THREE.MeshBasicMaterial({ color: 0xff0000 })
          );
          pointHelper.position.copy(pointLight.position);
          scene.add(pointHelper);

          const directionalLight = new THREE.DirectionalLight(0x0000ff, 10);
          directionalLight.position.set(-50, 10, 5);
          directionalLight.castShadow = true;
          scene.add(directionalLight);

          const dirHelper = new THREE.ArrowHelper(
              directionalLight.position.clone().normalize(),
              new THREE.Vector3(0, 0, 0),
              50,
              0x00ff00
          );
          scene.add(dirHelper);



          controls = new TrackballControls(camera, renderer.domElement);

        window.addEventListener("resize", handleWindowResize, false);
      }

      function createModel() {
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x38a800,
        });

        const treeTrunkMaterialPhong = new THREE.MeshPhongMaterial({
          color: 0x6b1717,
          specular: 0xfbf7f7,
          shininess: 100,
        });

        const treeLeafMaterial = new THREE.MeshStandardMaterial({
          color: 0x09ff21,
        });

        const rockMaterial = new THREE.MeshPhongMaterial({
          color: 0x808080,
          specular: 0xffff00,
            shininess: 10000,
        });

        const planeGeometry = new THREE.PlaneGeometry(10, 10, 4, 4);
        const planeMesh = new THREE.Mesh(planeGeometry, groundMaterial);

        planeMesh.receiveShadow = true;

        planeMesh.position.set(0, -5, 0);
        planeMesh.scale.set(50, 50, 50);
        planeMesh.rotation.x = -Math.PI / 2;

        scene.add(planeMesh);

        const cylinderGeometry = new THREE.CylinderGeometry(3.5, 5, 20, 8);
        treeTrunkMesh = new THREE.Mesh(
          cylinderGeometry,
          treeTrunkMaterialPhong
        );

        treeTrunkMesh.castShadow = true;
        treeTrunkMesh.receiveShadow = true;

        treeTrunkMesh.position.set(10, 25, -15);
        treeTrunkMesh.scale.set(0.5, 3, 0.5);

        scene.add(treeTrunkMesh);

        const branch1Mesh = new THREE.Mesh(
          cylinderGeometry,
          treeTrunkMaterialPhong
        );

        branch1Mesh.castShadow = true;

        branch1Mesh.position.set(12, 49, -11);
        branch1Mesh.scale.set(0.05, 0.5, 0.05);
        branch1Mesh.rotation.z = -Math.PI / 2 + 0.23;
        branch1Mesh.rotation.y = -0.95;

        scene.add(branch1Mesh);

        const branch2Mesh = new THREE.Mesh(
          cylinderGeometry,
          treeTrunkMaterialPhong
        );

        branch2Mesh.castShadow = true;

        branch2Mesh.position.set(6, 52, -15);
        branch2Mesh.scale.set(0.05, 0.3, 0.05);
        branch2Mesh.rotation.z = -Math.PI / 2 + 0.23;
        branch2Mesh.rotation.y = -Math.PI;

        scene.add(branch2Mesh);

        const branch3Mesh = new THREE.Mesh(
          cylinderGeometry,
          treeTrunkMaterialPhong
        );

        branch3Mesh.castShadow = true;

        branch3Mesh.position.set(10, 47.8, -18);
        branch3Mesh.scale.set(0.05, 0.42, 0.05);
        branch3Mesh.rotation.z = -Math.PI / 2 + 0.23;
        branch3Mesh.rotation.y = -1.48;

        scene.add(branch3Mesh);

        const branch4Mesh = new THREE.Mesh(
          cylinderGeometry,
          treeTrunkMaterialPhong
        );

        branch4Mesh.castShadow = true;

        branch4Mesh.position.set(12, 53, -18);
        branch4Mesh.scale.set(0.05, 0.25, 0.05);
        branch4Mesh.rotation.z = -Math.PI / 2 + 0.15;
        branch4Mesh.rotation.y = Math.PI + 0.85;

        scene.add(branch4Mesh);

        const octahedronGeometry = new THREE.OctahedronGeometry(5, 2);

        const leaf1Mesh = new THREE.Mesh(octahedronGeometry, treeLeafMaterial);
        leaf1Mesh.position.set(10, 58, -15);
        leaf1Mesh.scale.set(1.5, 1, 1.5);
        leaf1Mesh.rotation.y = 0.98;

        scene.add(leaf1Mesh);

        const leaf2Mesh = new THREE.Mesh(octahedronGeometry, treeLeafMaterial);
        leaf2Mesh.position.set(4, 52, -15);
        leaf2Mesh.scale.set(0.9, 0.8, 0.9);

        scene.add(leaf2Mesh);

        const leaf3Mesh = new THREE.Mesh(octahedronGeometry, treeLeafMaterial);
        leaf3Mesh.position.set(14, 49, -9);
        leaf3Mesh.scale.set(0.9, 0.9, 1);

        scene.add(leaf3Mesh);

        const leaf4Mesh = new THREE.Mesh(octahedronGeometry, treeLeafMaterial);
        leaf4Mesh.position.set(10, 47, -22);
        leaf4Mesh.scale.set(1.1, 0.9, 1.15);

        scene.add(leaf4Mesh);

        const leaf5Mesh = new THREE.Mesh(octahedronGeometry, treeLeafMaterial);
        leaf5Mesh.position.set(14, 51, -20);
        leaf5Mesh.scale.set(0.75, 0.8, 0.8);

        scene.add(leaf5Mesh);

        const icosahedronGeometry = new THREE.IcosahedronGeometry(10);

        const rock1Mesh = new THREE.Mesh(icosahedronGeometry, rockMaterial);
        rock1Mesh.position.set(-25, -3, 20);
        rock1Mesh.scale.set(0.5, 0.5, 0.5);
        rock1Mesh.rotation.x = 0.67;
        rock1Mesh.receiveShadow = true;
        rock1Mesh.castShadow = true;

        scene.add(rock1Mesh);

        const rock2Mesh = new THREE.Mesh(icosahedronGeometry, rockMaterial);
        rock2Mesh.position.set(-29, -3, 18);
        rock2Mesh.scale.set(0.66, 0.5, 0.66);
        rock2Mesh.rotation.x = 1.3;

        rock2Mesh.receiveShadow = true;
        rock2Mesh.castShadow = true;
        scene.add(rock2Mesh);

          const coloredMaterial = new THREE.MeshPhongMaterial({
              color: 0xff00ff,
              specular: 0x222222,
              shininess: 50
          });
          const coloredMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), coloredMaterial);
          coloredMesh.position.set(-10, 30, 0);
          coloredMesh.castShadow = true;

          scene.add(coloredMesh);

      }

      function handleWindowResize() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize(WIDTH, HEIGHT);
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();

        controls.handleResize();

        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
