<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "./js-r178/build/three.module.js",
          "TrackballControls": "./js-r178/examples/jsm/controls/TrackballControls.js",
          "OBJLoader": "./js-r178/examples/jsm/loaders/OBJLoader.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { TrackballControls } from "TrackballControls";
      import { OBJLoader } from "OBJLoader";

      let WIDTH, HEIGHT, aspectRatio;
      let renderer;
      let scene, camera;
      let geometry, material, mesh;
      let controls;
      let ambientLight, pointLight, directionalLight;
      let prevTime = 0;

      let boat;
      let isBoatMoving = false;

      const particles = [];

      async function loadTree() {
        const loader = new OBJLoader();
        const object = await loader.loadAsync("fa.obj");

        object.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            child.material = new THREE.MeshLambertMaterial({
              color: 0x6b1717,
              side: THREE.DoubleSide,
            });
          }
        });

        return object;
      }

      init();
      animate();

      async function init() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0x000000);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xcccccc, 0.005);

        camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.z = 100;
        camera.position.y = 40;
        camera.lookAt(scene.position);

        createTerrain();
        createTrees();

        // bridge over the water imn the middle
        // boat going through the river
        // sun and moon automatically moving, lighting changing

        ambientLight = new THREE.AmbientLight(0xffffff, 1);
        // ambientLight = new THREE.AmbientLight(0xecf300, 1);

        scene.add(ambientLight);
        // spotLight = new THREE.SpotLight(0xffffff, 50000);
        // spotLight.position.set(-40, 50, 20);
        // spotLight.angle = Math.PI / 8;
        // spotLight.target = treeTrunkMesh;
        // spotLight.penumbra = 0.8;
        // spotLight.distance = 5000;
        // spotLight.castShadow = true;

        // const arrowHelper = new THREE.ArrowHelper(
        //   spotLight.position.clone().normalize(),
        //   new THREE.Vector3(0, 0, 0),
        //   25,
        //   0x00ff00
        // );
        // scene.add(spotLight);
        // scene.add(arrowHelper);

        // pointLight = new THREE.PointLight(0xff0000, 2000, 100);
        // pointLight.position.set(15, 10, -10);

        // pointLight.castShadow = true;
        // scene.add(pointLight);

        // const pointHelper = new THREE.Mesh(
        //   new THREE.SphereGeometry(1),
        //   new THREE.MeshBasicMaterial({ color: 0xff0000 })
        // );
        // pointHelper.position.copy(pointLight.position);
        // scene.add(pointHelper);

        // const directionalLight = new THREE.DirectionalLight(0x0000ff, 10);
        // directionalLight.position.set(-50, 10, 5);
        // directionalLight.castShadow = true;
        // scene.add(directionalLight);

        // const dirHelper = new THREE.ArrowHelper(
        //   directionalLight.position.clone().normalize(),
        //   new THREE.Vector3(0, 0, 0),
        //   50,
        //   0x00ff00
        // );
        // scene.add(dirHelper);

        boat = createBoat();
        scene.add(boat);

        boat.scale.set(2, 2, 2);

        boat.rotation.y = (Math.PI / 16) * 7;
        boat.position.set(-160, 16, 150);

        controls = new TrackballControls(camera, renderer.domElement);

        window.addEventListener("resize", handleWindowResize, false);
        window.addEventListener("click", handleClickEvent, false);
      }

      function createTerrain() {
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x38a800,
          displacementMap: new THREE.TextureLoader().load(
            "river_displacement.png"
          ),
          displacementScale: 0.5,
        });

        const waterMaterial = new THREE.MeshPhongMaterial({
          color: 0x0000cc,
          specular: 0xffffff,
          shininess: 10,
        });

        const planeGeometry = new THREE.PlaneGeometry(10, 10, 256, 256);
        const planeMesh = new THREE.Mesh(planeGeometry, groundMaterial);

        planeMesh.receiveShadow = true;

        planeMesh.position.set(0, -5, 0);
        planeMesh.scale.set(50, 50, 50);
        planeMesh.rotation.x = -Math.PI / 2;

        scene.add(planeMesh);

        const waterGeometry = new THREE.PlaneGeometry(10, 10, 4, 4);
        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);

        waterMesh.position.set(0, 16, 0);
        waterMesh.scale.set(50, 50, 50);
        waterMesh.rotation.x = -Math.PI / 2;

        waterMesh.receiveShadow = true;

        scene.add(waterMesh);
      }

      async function createTrees() {
        const treePositions = [
          { x: -243, z: -243, rotation: 9 },
          { x: 120, z: -87, rotation: 3 },
          { x: -45, z: 200, rotation: 15 },
          { x: 250, z: -12, rotation: 0 },
          { x: -210, z: 134, rotation: 14 },
          { x: 56, z: 220, rotation: 5 },
          { x: 33, z: 188, rotation: 6 },
          { x: -67, z: -199, rotation: 12 },
          { x: 201, z: 77, rotation: 4 },
          { x: 75, z: -220, rotation: 10 },
          { x: -188, z: 99, rotation: 13 },
          { x: 222, z: -56, rotation: 9 },
          { x: -44, z: 144, rotation: 15 },
          { x: 98, z: -88, rotation: 0 },
          { x: -156, z: 233, rotation: 7 },
          { x: 187, z: -177, rotation: 2 },
          { x: -210, z: -111, rotation: 5 },
          { x: -77, z: 66, rotation: 3 },
          { x: 210, z: -34, rotation: 12 },
          { x: 45, z: -145, rotation: 8 },
          { x: -88, z: 222, rotation: 11 },
          { x: -33, z: 99, rotation: 4 },
          { x: 144, z: -67, rotation: 13 },
          { x: 188, z: -201, rotation: 10 },
          { x: -56, z: 132, rotation: 9 },
          { x: 99, z: -75, rotation: 15 },
          { x: -220, z: 187, rotation: 2 },
          { x: -111, z: 134, rotation: 5 },
          { x: -34, z: 210, rotation: 3 },
          { x: 222, z: -88, rotation: 8 },
          { x: 99, z: -33, rotation: 16 },
          { x: -67, z: 144, rotation: 4 },
          { x: -201, z: 75, rotation: 1 },
        ];

        const treeModel = await loadTree();

        for (const position of treePositions) {
          const clone = treeModel.clone(true);

          clone.scale.set(5, 5, 5);
          clone.position.set(position.x, 24, position.z);

          clone.rotation.y = (Math.PI / 16) * position.rotation;

          clone.castShadow = true;
          clone.receiveShadow = true;

          scene.add(clone);
        }
      }

      function createBoat() {
        const boatHullMaterial = new THREE.MeshStandardMaterial({
          color: 0x8b4513,
        });

        const boatPlankMaterial = new THREE.MeshStandardMaterial({
          color: 0xa34e16,
        });

        const hullBottom = new THREE.Mesh(
          new THREE.BoxGeometry(4, 0.1, 2),
          boatHullMaterial
        );

        const hullSide1 = new THREE.Mesh(
          new THREE.BoxGeometry(4, 0.7, 0.1),
          boatHullMaterial
        );
        hullSide1.position.set(0, 0.3, 1);

        const hullSide2 = new THREE.Mesh(
          new THREE.BoxGeometry(4, 0.7, 0.1),
          boatHullMaterial
        );
        hullSide2.position.set(0, 0.3, -1);

        const hullBack = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.7, 2),
          boatHullMaterial
        );
        hullBack.position.set(-2, 0.3, 0);

        const hullFront1 = new THREE.Mesh(
          new THREE.BoxGeometry(1.35, 0.7, 0.1),
          boatHullMaterial
        );
        hullFront1.position.set(2.4, 0.3, 0.5);
        hullFront1.rotation.y = Math.PI / 4;

        const hullFront2 = new THREE.Mesh(
          new THREE.BoxGeometry(1.35, 0.7, 0.1),
          boatHullMaterial
        );
        hullFront2.position.set(2.4, 0.3, -0.5);
        hullFront2.rotation.y = -Math.PI / 4;

        const hullFrontBottom1 = new THREE.Mesh(
          new THREE.BoxGeometry(1.55, 0.8, 0.1),
          boatHullMaterial
        );
        hullFrontBottom1.position.set(2.2, 0, -0.3);
        hullFrontBottom1.rotation.z = Math.PI / 4;
        hullFrontBottom1.rotation.x = Math.PI / 2;

        const hullFrontBottom2 = new THREE.Mesh(
          new THREE.BoxGeometry(1.55, 0.8, 0.1),
          boatHullMaterial
        );
        hullFrontBottom2.position.set(2.2, 0, 0.3);
        hullFrontBottom2.rotation.z = -Math.PI / 4;
        hullFrontBottom2.rotation.x = Math.PI / 2;

        const plank1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.1, 2),
          boatPlankMaterial
        );
        plank1.position.set(0, 0.4, 0);

        const plank2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.1, 2),
          boatPlankMaterial
        );
        plank2.position.set(-1, 0.4, 0);

        const plank3 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.1, 2),
          boatPlankMaterial
        );
        plank3.position.set(1, 0.4, 0);

        const plank4 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.1, 2),
          boatPlankMaterial
        );
        plank4.position.set(-1.75, 0.4, 0);

        const mast = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 3),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        mast.position.set(0, 1.9, 0);

        const sail = new THREE.Mesh(
          new THREE.PlaneGeometry(2, 2),
          new THREE.MeshStandardMaterial({
            color: 0xffff00,
            side: THREE.DoubleSide,
          })
        );
        sail.position.set(0, 2.5, 0);
        sail.rotation.y = Math.PI / 2;

        const boat = new THREE.Group();
        boat.add(hullBottom);
        boat.add(hullSide1);
        boat.add(hullSide2);
        boat.add(hullBack);
        boat.add(hullFront1);
        boat.add(hullFront2);
        boat.add(hullFrontBottom1);
        boat.add(hullFrontBottom2);
        boat.add(mast);
        boat.add(sail);
        boat.add(plank1);
        boat.add(plank2);
        boat.add(plank3);
        boat.add(plank4);

        boat.traverse((child) => {
          if (child.isMesh) {
            child.receiveShadow = true;
            child.castShadow = true;
          }
        });

        return boat;
      }

      function handleWindowResize() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize(WIDTH, HEIGHT);
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();

        controls.handleResize();

        render();
      }

      function handleClickEvent(event) {
        const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();

        raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);

        if (!isBoatMoving) {
          const intersects = raycaster.intersectObjects(boat.children, true);

          if (intersects.length > 0) {
            isBoatMoving = true;
          }
        }
      }

      let boatProgress = 0;

      function animate(frameTime) {
        const deltaSeconds = (frameTime - prevTime) / 1000;
        prevTime = frameTime;

        requestAnimationFrame(animate);
        controls.update();

        particles.forEach((particle) => {
          if (particle.isDead) {
              scene.remove(particle.points);
              particle.dispose();
          }

          particle.update();
        });

        if (isBoatMoving) {
          console.log(boatProgress);

          boatProgress += deltaSeconds;

          if (boatProgress < 38) {
            boat.translateX(14.28 * deltaSeconds);
          }

          if (boatProgress > 9 && boatProgress < 10) {
            boat.rotateY(-0.714 * deltaSeconds);
          }

          if (boatProgress > 12.5 && boatProgress < 13.5) {
            boat.rotateY(-0.357 * deltaSeconds);
          }

          if (boatProgress > 21 && boatProgress < 22.5) {
            boat.rotateY(0.357 * deltaSeconds);
          }

          if (boatProgress > 27 && boatProgress < 27.5) {
            boat.rotateY(0.357 * deltaSeconds);
          }

          if (boatProgress > 33 && boatProgress < 33.5) {
            boat.rotateY(0.357 * deltaSeconds);
          }

          if (boatProgress > 38) {
            const endTeleportParticles = new TeleportParticles(
              boat.position.x,
              boat.position.y,
              boat.position.z,
              5,
              10,
              200
            );
            scene.add(endTeleportParticles.points);
            particles.push(endTeleportParticles);

            isBoatMoving = false;
            boat.rotation.y = (Math.PI / 16) * 7;
            boat.position.set(-160, 16, 150);
            boatProgress = 0;

            const startTeleportParticles = new TeleportParticles(
              boat.position.x,
              boat.position.y,
              boat.position.z,
              5,
              10,
              200
            );
            scene.add(startTeleportParticles.points);
            particles.push(startTeleportParticles);
          }
        }

        render();
      }

      function render() {
        renderer.render(scene, camera);
      }

      class TeleportParticles {
        constructor(x, y, z, lifetime, spread, count) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.lifetime = lifetime;

          this.dead = false;

          const particleCount = count;
          this.geometry = new THREE.BufferGeometry();
          const positions = [];

          for (let i = 0; i < particleCount; i++) {
            positions.push(
              (Math.random() - 0.5) * spread,
              (Math.random() - 0.5) * spread,
              (Math.random() - 0.5) * spread
            );
          }

          this.geometry.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3)
          );

          this.material = new THREE.PointsMaterial({
            color: 0x7526a0,
            size: 1,
            transparent: true,
            opacity: 0.8,
          });

          this.particles = new THREE.Points(this.geometry, this.material);
          this.particles.position.set(x, y, z);
        }

        get points() {
          return this.particles;
        }

        get isDead() {
          return this.dead;
        }

        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }

        update() {
          if (this.material.opacity <= 0) {
            this.dead = true;
            return;
          }

          const pos = this.geometry.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            pos.setXYZ(
              i,
              pos.getX(i) + (Math.random() - 0.5) * 0.1,
              pos.getY(i) + (Math.random() - 0.5) * 0.1,
              pos.getZ(i) + (Math.random() - 0.5) * 0.1
            );
          }
          pos.needsUpdate = true;
          this.material.opacity -= 0.01 / this.lifetime;
        }
      }
    </script>
  </body>
</html>
