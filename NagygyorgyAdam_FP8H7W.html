<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Document</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 50%;
            text-align: left;
            z-index: 100;
            display: block;
            color: cyan;
            opacity: 1.0;
        }

        #info2 {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 50%;
            text-align: right;
            z-index: 100;
            display: block;
            color: cyan;
            opacity: 1.0;
        }
    </style>
</head>

<body>

<div id="info">
    <p id="infopanel"></p>
</div>

<div id="info2">
    <p>T - Nap mozgása ki/be</p>
    <p>Z - Nap ki/be</p>
    <p>WASD - Kamera mozgatása</p>
    <p>U - Szélkerék lámpa ki/be</p>
    <p>A csónak kattintásra indul</p>
</div>

<script type="importmap">
    {
      "imports": {
        "three": "./js-r178/build/three.module.js",
        "TrackballControls": "./js-r178/examples/jsm/controls/TrackballControls.js",
        "OBJLoader": "./js-r178/examples/jsm/loaders/OBJLoader.js"
      }
    }
</script>

<script type="module">
    import * as THREE from "three";
    import {TrackballControls} from "TrackballControls";
    import {OBJLoader} from "OBJLoader";

    let WIDTH, HEIGHT, aspectRatio;
    let renderer;
    let scene, camera;
    let geometry, material, mesh;
    let controls;
    let prevTime = 0;

    let boat;
    let boatPointLight;
    let isBoatMoving = false;

    let sunPivot, sunLight;
    let isSunEnabled = true;
    let isSunMoving = false;

    let windmillSpinner;
    let windmillTopPart;
    let windmillLight;

    let gooMaterial;
    let cauldronLight;

    let waterMaterial;

    const particles = [];
    const keys = {};

    const manager = new THREE.LoadingManager();

    manager.onLoad = async function () {
        await init();
        animate();
    };

    const textureLoader = new THREE.TextureLoader(manager);
    const grassTexture = textureLoader.load('grass.png');
    grassTexture.wrapS = THREE.RepeatWrapping;
    grassTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.repeat.set(8, 8);

    const treeTexture = textureLoader.load('tree.png');
    treeTexture.wrapS = THREE.RepeatWrapping;
    treeTexture.wrapT = THREE.RepeatWrapping;
    treeTexture.repeat.set(3, 3);

    const riverTexture = textureLoader.load('river.png');
    riverTexture.wrapS = THREE.RepeatWrapping;
    riverTexture.wrapT = THREE.RepeatWrapping;
    riverTexture.repeat.set(2, 2);

    const riverDisplacementMap = textureLoader.load('river_displacement.png');
    const riverBump = textureLoader.load('river_bump.png');

    const gooTexture = textureLoader.load('goo.png');
    gooTexture.wrapS = THREE.RepeatWrapping;
    gooTexture.wrapT = THREE.RepeatWrapping;
    gooTexture.repeat.set(2, 2);

    async function loadTree() {
        const loader = new OBJLoader();
        const object = await loader.loadAsync("fa.obj");

        object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.material = new THREE.MeshLambertMaterial({
                    color: 0x6b1717,
                    side: THREE.DoubleSide,
                    map: treeTexture
                });
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        return object;
    }

    async function loadCauldron(){
        const loader = new OBJLoader();
        const object = await loader.loadAsync("cauldron.obj");

        object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.material = new THREE.MeshStandardMaterial({
                    color: 0x6B6B6B,
                    side: THREE.DoubleSide,
                })

                child.castShadow = true;
                child.receiveShadow = true;
            }
        })

        return object;
    }

    let infoPanel;

    function setInfoPanelText(msg) {
        infoPanel.innerHTML = msg;
    }

    async function init() {
        infoPanel = document.getElementById('infopanel');

        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(0x000000);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xcccccc, 0.0025);

        camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.z = 100;
        camera.position.y = 50;
        camera.lookAt(0, 40, 0)

        createTerrain();
        createTrees();

        const ambient = new THREE.AmbientLight(0x404040, 5);
        scene.add(ambient);

        sunPivot = new THREE.Object3D();
        scene.add(sunPivot);

        sunLight = new THREE.DirectionalLight(0xffffff, 2.0); // bright white
        sunLight.position.set(50, 100, 50); // position high above
        sunLight.castShadow = true; // enable shadows
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -300;
        sunLight.shadow.camera.right = 300;
        sunLight.shadow.camera.top = 300;
        sunLight.shadow.camera.bottom = -300;

        sunLight.position.set(0, 200, -50);

        sunPivot.add(sunLight);

        boat = createBoat();
        scene.add(boat);

        boat.scale.set(2, 2, 2);

        boat.rotation.y = (Math.PI / 16) * 7;
        boat.position.set(-160, 17, 150);

        const windmill = createWindmill();
        windmillSpinner = windmill.spinner;
        windmillTopPart = windmill.rotatingPart;

        scene.add(windmill.group);

        windmill.group.position.set(-80, 30, -80);
        windmill.group.rotation.y = -Math.PI / 6;

        const campfire = await createCampfire();
        campfire.rotation.x = Math.PI / 2;

        campfire.position.set(0,20,0)
        scene.add(campfire);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        setInfoPanelText("Nagygyörgy Ádám FP8H7W gazdaságinformatikus 2025/26/1")

        window.addEventListener("resize", handleWindowResize, false);
        window.addEventListener("click", handleClickEvent, false);
        window.addEventListener("keyup", handleKeyUpEvent, false)
        window.addEventListener("keydown", (event) => {
            keys[event.code] = true
        }, false)
        window.addEventListener("keyup", (event) => {
            keys[event.code] = false
        }, false)
    }

    function createTerrain() {
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x38a800,
            displacementMap: riverDisplacementMap,
            displacementScale: 0.5,
            map: grassTexture
        });

        waterMaterial = new THREE.MeshStandardMaterial({
            color: 0xaa00cc,
            map: riverTexture,
            displacementMap: riverBump,
            displacementScale: 0.02,
        });

        const planeGeometry = new THREE.PlaneGeometry(10, 10, 256, 256);
        const planeMesh = new THREE.Mesh(planeGeometry, groundMaterial);

        planeMesh.receiveShadow = true;
        planeMesh.castShadow = true;

        planeMesh.position.set(0, -5, 0);
        planeMesh.scale.set(50, 50, 50);
        planeMesh.rotation.x = -Math.PI / 2;

        scene.add(planeMesh);

        const waterGeometry = new THREE.PlaneGeometry(10, 10, 4, 4);
        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);

        waterMesh.position.set(0, 16, 0);
        waterMesh.scale.set(50, 50, 50);
        waterMesh.rotation.x = -Math.PI / 2;

        waterMesh.receiveShadow = true;

        scene.add(waterMesh);
    }

    async function createTrees() {
        const treePositions = [
            {x: -243, z: -243, rotation: 9},
            {x: 120, z: -87, rotation: 3},
            {x: -45, z: 200, rotation: 15},
            {x: 250, z: -12, rotation: 0},
            {x: -210, z: 134, rotation: 14},
            {x: 56, z: 220, rotation: 5},
            {x: 33, z: 188, rotation: 6},
            {x: -67, z: -199, rotation: 12},
            {x: 201, z: 77, rotation: 4},
            {x: 75, z: -220, rotation: 10},
            {x: -188, z: 99, rotation: 13},
            {x: 222, z: -56, rotation: 9},
            {x: -44, z: 144, rotation: 15},
            {x: 98, z: -88, rotation: 0},
            {x: -156, z: 233, rotation: 7},
            {x: 187, z: -177, rotation: 2},
            {x: -210, z: -111, rotation: 5},
            {x: -77, z: 66, rotation: 3},
            {x: 210, z: -34, rotation: 12},
            {x: 45, z: -145, rotation: 8},
            {x: -88, z: 222, rotation: 11},
            {x: -33, z: 99, rotation: 4},
            {x: 144, z: -67, rotation: 13},
            {x: 188, z: -201, rotation: 10},
            {x: -56, z: 132, rotation: 9},
            {x: 99, z: -75, rotation: 15},
            {x: -220, z: 187, rotation: 2},
            {x: -111, z: 134, rotation: 5},
            {x: -34, z: 210, rotation: 3},
            {x: 222, z: -88, rotation: 8},
            {x: 99, z: -33, rotation: 16},
            {x: -67, z: 144, rotation: 4},
            {x: -201, z: 75, rotation: 1},
        ];

        const treeModel = await loadTree();

        for (const position of treePositions) {
            const clone = treeModel.clone(true);

            clone.scale.set(5, 5, 5);
            clone.position.set(position.x, 24, position.z);

            clone.rotation.y = (Math.PI / 16) * position.rotation;

            clone.castShadow = true;
            clone.receiveShadow = true;

            scene.add(clone);
        }
    }

    async function createCampfire(){
        const plankMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
        });

        const plankGeometry = new THREE.BoxGeometry(10,1,2);

        const planks = new THREE.Group();

        const plankCount = 12;
        for (let i = 0; i < plankCount; i++) {
            const plank = new THREE.Mesh(plankGeometry, plankMaterial);
            plank.castShadow = true;
            plank.receiveShadow = true;

            plank.rotation.z = (i * Math.PI * 2) / plankCount;
            planks.add(plank)
        }

        const cauldron = await loadCauldron();

        cauldron.rotation.x = -Math.PI / 2;
        cauldron.position.set(0, 0, -3.6);

        cauldron.scale.set(2.5, 2.5, 2.5);

        const steam = new SteamParticles(0,6,0,10);
        steam.particles.rotation.x = -Math.PI / 2;

        planks.add(cauldron)
        planks.add(steam.particles);
        particles.push(steam);

        gooMaterial = new THREE.MeshStandardMaterial({
            color: 0x00cc00,
            map: gooTexture
        })
        const goo = new THREE.Mesh(new THREE.PlaneGeometry(1.6,1.6,4,4),gooMaterial);
        cauldron.add(goo)
        goo.rotation.x = -Math.PI / 2;
        goo.position.set(0, 0.7, 0)

        cauldronLight = new THREE.PointLight(0xFF6A00, 1000, 25, 1);
        cauldronLight.position.set(0, 0, -1.1);
        cauldronLight.castShadow = true;

        planks.add(cauldronLight);

        planks.traverse((child)=>{
            if (child.isMesh){
                child.castShadow = true;
                child.receiveShadow = true;
            }
        })

        return planks;
    }

    function createWindmill() {
        const plankMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
        });

        const plankRotationAngle = Math.PI / 16;
        const plankOffset = 2;

        const plank1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 20, 0.5), plankMaterial);

        plank1.position.set(-plankOffset, 0, -plankOffset);
        plank1.rotation.x = plankRotationAngle;
        plank1.rotation.z = -plankRotationAngle;

        const plank2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 20, 0.5), plankMaterial);

        plank2.position.set(plankOffset, 0, -plankOffset);
        plank2.rotation.x = plankRotationAngle;
        plank2.rotation.z = plankRotationAngle;

        const plank3 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 20, 0.5), plankMaterial);

        plank3.position.set(plankOffset, 0, plankOffset);
        plank3.rotation.x = -plankRotationAngle;
        plank3.rotation.z = plankRotationAngle;

        const plank4 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 20, 0.5), plankMaterial);

        plank4.position.set(-plankOffset, 0, plankOffset);
        plank4.rotation.x = -plankRotationAngle;
        plank4.rotation.z = -plankRotationAngle;

        const topPlank1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 4, 0.4), plankMaterial);
        topPlank1.position.set(0, 10, 0);

        topPlank1.castShadow = true;
        topPlank1.receiveShadow = true;

        const topPlank2 = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 0.4), plankMaterial);
        topPlank2.position.set(0.2, 1.5, 0);

        topPlank2.castShadow = true;
        topPlank2.receiveShadow = true;

        topPlank1.add(topPlank2);

        const bladeLength = 8;
        const bladeCount = 8;

        const bladeGeometry = new THREE.BoxGeometry(0.4, bladeLength, 0.05);
        const bladeMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, specular: 0xffffff, shininess: 1000});

        const spinner = new THREE.Group();

        for (let i = 0; i < bladeCount; i++) {
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.castShadow = true;
            blade.receiveShadow = true;

            blade.rotation.z = (i * Math.PI * 2) / bladeCount;
            spinner.add(blade);
        }

        const hub = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32),
            new THREE.MeshStandardMaterial({color: 0x888888})
        );

        hub.castShadow = true;
        hub.receiveShadow = true;

        hub.rotation.x = -Math.PI / 2;

        spinner.add(hub);

        spinner.rotation.y = -Math.PI / 2;
        spinner.position.set(0.7, 0, 0);
        topPlank2.add(spinner);

        windmillLight = new THREE.PointLight(0xff0000, 200, 30, 1.2);
        windmillLight.position.set(0, 5, 0);
        windmillLight.castShadow = true;

        hub.add(windmillLight);

        const windmill = new THREE.Group();
        windmill.add(plank1);
        windmill.add(plank2);
        windmill.add(plank3);
        windmill.add(plank4);
        windmill.add(topPlank1);

        windmill.traverse((child) => {
            if (child.isMesh) {
                child.receiveShadow = true;
                child.castShadow = true;
            }
        });

        return {group: windmill, rotatingPart: topPlank1, spinner: spinner};
    }

    function createBoat() {
        const boatHullMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
        });

        const boatPlankMaterial = new THREE.MeshStandardMaterial({
            color: 0xa34e16,
        });

        const hullBottom = new THREE.Mesh(
            new THREE.BoxGeometry(4, 0.1, 2),
            boatHullMaterial
        );

        const hullSide1 = new THREE.Mesh(
            new THREE.BoxGeometry(4, 0.7, 0.1),
            boatHullMaterial
        );
        hullSide1.position.set(0, 0.3, 1);

        const hullSide2 = new THREE.Mesh(
            new THREE.BoxGeometry(4, 0.7, 0.1),
            boatHullMaterial
        );
        hullSide2.position.set(0, 0.3, -1);

        const hullBack = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.7, 2),
            boatHullMaterial
        );
        hullBack.position.set(-2, 0.3, 0);

        const hullFront1 = new THREE.Mesh(
            new THREE.BoxGeometry(1.35, 0.7, 0.1),
            boatHullMaterial
        );
        hullFront1.position.set(2.4, 0.3, 0.5);
        hullFront1.rotation.y = Math.PI / 4;

        const hullFront2 = new THREE.Mesh(
            new THREE.BoxGeometry(1.35, 0.7, 0.1),
            boatHullMaterial
        );
        hullFront2.position.set(2.4, 0.3, -0.5);
        hullFront2.rotation.y = -Math.PI / 4;

        const hullFrontBottom1 = new THREE.Mesh(
            new THREE.BoxGeometry(1.55, 0.8, 0.1),
            boatHullMaterial
        );
        hullFrontBottom1.position.set(2.2, 0, -0.3);
        hullFrontBottom1.rotation.z = Math.PI / 4;
        hullFrontBottom1.rotation.x = Math.PI / 2;

        const hullFrontBottom2 = new THREE.Mesh(
            new THREE.BoxGeometry(1.55, 0.8, 0.1),
            boatHullMaterial
        );
        hullFrontBottom2.position.set(2.2, 0, 0.3);
        hullFrontBottom2.rotation.z = -Math.PI / 4;
        hullFrontBottom2.rotation.x = Math.PI / 2;

        const plank1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.1, 2),
            boatPlankMaterial
        );
        plank1.position.set(0, 0.4, 0);

        const plank2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.1, 2),
            boatPlankMaterial
        );
        plank2.position.set(-1, 0.4, 0);

        const plank3 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.1, 2),
            boatPlankMaterial
        );
        plank3.position.set(1, 0.4, 0);

        const plank4 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.1, 2),
            boatPlankMaterial
        );
        plank4.position.set(-1.75, 0.4, 0);

        const mast = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.1, 3),
            new THREE.MeshStandardMaterial({color: 0xffffff})
        );
        mast.position.set(0, 1.9, 0);

        boatPointLight = new THREE.PointLight(0xffffcc, 30, 30, 1);
        boatPointLight.position.set(0, 3.8, 0);

        const sail = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            new THREE.MeshStandardMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
            })
        );
        sail.position.set(0, 2.5, 0);
        sail.rotation.y = Math.PI / 2;

        const boat = new THREE.Group();
        boat.add(hullBottom);
        boat.add(hullSide1);
        boat.add(hullSide2);
        boat.add(hullBack);
        boat.add(hullFront1);
        boat.add(hullFront2);
        boat.add(hullFrontBottom1);
        boat.add(hullFrontBottom2);
        boat.add(mast);
        boat.add(sail);
        boat.add(plank1);
        boat.add(plank2);
        boat.add(plank3);
        boat.add(plank4);
        boat.add(boatPointLight);

        boat.traverse((child) => {
            if (child.isMesh) {
                child.receiveShadow = true;
                child.castShadow = true;
            }
        });

        return boat;
    }

    function handleWindowResize() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize(WIDTH, HEIGHT);
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();

        controls.handleResize();

        render();
    }

    function handleClickEvent(event) {
        const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();

        raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);

        if (!isBoatMoving) {
            const intersects = raycaster.intersectObjects(boat.children, true);

            if (intersects.length > 0) {
                isBoatMoving = true;
            }
        }
    }

    function handleKeyUpEvent(event) {
        if (event.key === 'i') {
            const info = document.getElementById('info');
            const info2 = document.getElementById('info2');

            if (info.style.display !== 'none') {
                info.style.display = 'none';
                info2.style.display = 'none';
            } else {
                info.style.display = 'block';
                info2.style.display = 'block';
            }
        }

        if (event.key === 't') {
            isSunMoving = !isSunMoving;
        }

        if (event.key === 'z') {
            if (isSunEnabled) {
                sunPivot.remove(sunLight);
            } else {
                sunPivot.add(sunLight);
            }

            isSunEnabled = !isSunEnabled;
        }

        if (event.key === 'u') {
            windmillLight.visible = !windmillLight.visible;
        }
    }

    const speed = 1;

    function updateCameraMovement() {
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);

        const right = new THREE.Vector3();
        right.crossVectors(camera.up, forward).normalize();

        if (keys['KeyW']) {
            camera.position.addScaledVector(forward, speed);
            controls.target.addScaledVector(forward, speed);
        }
        if (keys['KeyS']) {
            camera.position.addScaledVector(forward, -speed);
            controls.target.addScaledVector(forward, -speed);
        }
        if (keys['KeyA']) {
            camera.position.addScaledVector(right, speed);
            controls.target.addScaledVector(right, speed);
        }
        if (keys['KeyD']) {
            camera.position.addScaledVector(right, -speed);
            controls.target.addScaledVector(right, -speed);
        }
    }

    let boatProgress = 0;

    function animate(frameTime) {

        if (isSunMoving) {
            sunPivot.rotation.z -= 0.003;
        }


        const deltaSeconds = (frameTime - prevTime) / 1000;
        prevTime = frameTime;

        if (!isNaN(frameTime)) {
            windmillSpinner.rotation.x += 0.03;
            windmillTopPart.rotation.y += 0.003 * Math.sin(frameTime / 1000);

            windmillLight.intensity = 200 + Math.sin(frameTime / 500)*200;

            cauldronLight.intensity = 1000+ Math.sin(frameTime / 100)*700;
        }


        requestAnimationFrame(animate);

        updateCameraMovement();
        controls.update();

        gooMaterial.map.offset.y += 0.05;
        gooMaterial.map.offset.x += 0.025;

        waterMaterial.map.offset.y += -0.00025;

        particles.forEach((particle) => {
            if (particle.isDead) {
                scene.remove(particle.points);
                particle.dispose();
            }

            particle.update();
        });

        if (isBoatMoving) {
            boatProgress += deltaSeconds;

            if (boatProgress < 38) {
                boat.translateX(14.28 * deltaSeconds);
            }

            if (boatProgress > 9 && boatProgress < 10) {
                boat.rotateY(-0.714 * deltaSeconds);
            }

            if (boatProgress > 12.5 && boatProgress < 13.5) {
                boat.rotateY(-0.357 * deltaSeconds);
            }

            if (boatProgress > 21 && boatProgress < 22.5) {
                boat.rotateY(0.357 * deltaSeconds);
            }

            if (boatProgress > 27 && boatProgress < 27.5) {
                boat.rotateY(0.357 * deltaSeconds);
            }

            if (boatProgress > 33 && boatProgress < 33.5) {
                boat.rotateY(0.357 * deltaSeconds);
            }

            if (boatProgress > 38) {
                const endTeleportParticles = new TeleportParticles(
                    boat.position.x,
                    boat.position.y,
                    boat.position.z,
                    5,
                    10,
                    200
                );
                scene.add(endTeleportParticles.points);
                particles.push(endTeleportParticles);

                isBoatMoving = false;
                boat.rotation.y = (Math.PI / 16) * 7;
                boat.position.set(-160, 17, 150);
                boatProgress = 0;

                const startTeleportParticles = new TeleportParticles(
                    boat.position.x,
                    boat.position.y,
                    boat.position.z,
                    5,
                    10,
                    200
                );
                scene.add(startTeleportParticles.points);
                particles.push(startTeleportParticles);
            }
        }

        render();
    }

    function render() {
        renderer.render(scene, camera);
    }

    class TeleportParticles {
        constructor(x, y, z, lifetime, spread, count) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.lifetime = lifetime;

            this.dead = false;

            const particleCount = count;
            this.geometry = new THREE.BufferGeometry();
            const positions = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread
                );
            }

            this.geometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(positions, 3)
            );

            this.material = new THREE.PointsMaterial({
                color: 0x7526a0,
                size: 1,
                transparent: true,
                opacity: 0.8,
            });

            this.particles = new THREE.Points(this.geometry, this.material);
            this.particles.position.set(x, y, z);
        }

        get points() {
            return this.particles;
        }

        get isDead() {
            return this.dead;
        }

        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }

        update() {
            if (this.material.opacity <= 0) {
                this.dead = true;
                return;
            }

            const pos = this.geometry.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                pos.setXYZ(
                    i,
                    pos.getX(i) + (Math.random() - 0.5) * 0.1,
                    pos.getY(i) + (Math.random() - 0.5) * 0.1,
                    pos.getZ(i) + (Math.random() - 0.5) * 0.1
                );
            }
            pos.needsUpdate = true;
            this.material.opacity -= 0.01 / this.lifetime;
        }
    }

    class SteamParticles {
        constructor(x, y, z, maxCount = 200) {
            this.origin = new THREE.Vector3(x, y, z);
            this.maxCount = maxCount;

            this.geometry = new THREE.BufferGeometry();
            this.positions = new Float32Array(maxCount * 3);
            this.lifetimes = new Float32Array(maxCount);
            this.ages = new Float32Array(maxCount);

            this.geometry.setAttribute("position", new THREE.BufferAttribute(this.positions, 3));

            this.material = new THREE.PointsMaterial({
                size: 0.5,
                transparent: true,
                opacity: 0.5,
                vertexColors: true,
            });

            this.colors = new Float32Array(maxCount * 3);
            this.geometry.setAttribute("color", new THREE.BufferAttribute(this.colors, 3));

            this.particles = new THREE.Points(this.geometry, this.material);

            for (let i = 0; i < maxCount; i++) {
                this.resetParticle(i, true);
            }
        }

        resetParticle(i, initial = false) {
            this.positions[i * 3] = this.origin.x;
            this.positions[i * 3 + 1] = this.origin.y;
            this.positions[i * 3 + 2] = this.origin.z;

            this.ages[i] = 0;
            this.lifetimes[i] = 60 + Math.random() * 30;

            this.colors[i * 3] = 1.0;
            this.colors[i * 3 + 1] = 1.0;
            this.colors[i * 3 + 2] = 1.0;

            if (!initial) {
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
            }
        }

        update() {
            const pos = this.geometry.attributes.position;
            const col = this.geometry.attributes.color;

            for (let i = 0; i < this.maxCount; i++) {
                this.ages[i]++;

                if (this.ages[i] >= this.lifetimes[i]) {
                    this.resetParticle(i);
                    continue;
                }

                this.positions[i * 3 + 1] += 0.1;

                this.positions[i * 3] += (Math.random() - 0.5) * 0.2;
                this.positions[i * 3 + 2] += (Math.random() - 0.5) * 0.2;

                const lifeRatio = this.ages[i] / this.lifetimes[i];
                const fade = 1.0 - lifeRatio;
                col.array[i * 3] = fade;
                col.array[i * 3 + 1] = fade;
                col.array[i * 3 + 2] = fade;

                this.material.size = 0.5 + lifeRatio * 1.5;
            }

            pos.needsUpdate = true;
            col.needsUpdate = true;
        }

        get points() {
            return this.particles;
        }
    }

</script>
</body>
</html>
